# 实验一：快速排序算法及其优化

**姓名**：高宇轩  

**学号**：SA25218104  

**仓库地址**：https://github.com/91gaozhidao/AlgorithmLab

**实验日期**：2025年11月7日

---

## 一、实验内容

本实验主要包含两个部分：

**第一部分：快速排序的基本实现**

- 编程实现快速排序算法

**第二部分：快速排序的优化**

1. 基准选择策略的对比（固定基准、随机基准、三数取中）
2. 混合插入排序优化
3. 并行化优化（多线程快速排序）

---

## 二、算法思想

### 2.1 快速排序基本思想

快速排序是一种采用分治策略的排序算法，其核心思想如下：

1. **分区（Partition）**：选择一个基准元素（pivot），将数组划分为两部分，使得左边部分的元素都小于等于基准，右边部分的元素都大于基准。

2. **递归排序**：对左右两个子数组分别递归地进行快速排序。

3. **合并**：由于是原地排序，不需要额外的合并步骤。

### 2.2 优化策略

#### 2.2.1 基准选择优化

**① 固定基准**：选择数组最后一个元素作为基准，适用于完全随机的数据

**② 随机基准**：随机选择一个元素作为基准，适用于无法预知数据特征且需要稳定性能时

**③ 三数取中**：选择首、中、尾三个元素的中位数作为基准，适用于通用场景，工程实践中最常用

#### 2.2.2 混合插入排序优化

当子数组长度小于阈值K时，使用插入排序代替快速排序：

- **优化原理**：
  - 插入排序在小规模数据（<30个元素）上效率很高
  - 快速排序的递归调用有固定开销（函数调用、栈操作）
  - 插入排序常数因子小，无递归开销
- **K值选择**：通过实验测试不同K值（5, 10, 15, 20, 30）找出最优阈值
  - K过小：插入排序优势未充分发挥
  - K增大：性能持续提升（在测试范围内）
  - 本实验最优值：K = 30

#### 2.2.3 并行化优化

利用多线程并行处理左右子数组：

- **并行策略**：使用C++11的`std::async`实现异步并行
  - 左子数组：创建异步任务在新线程中执行
  - 右子数组：当前线程继续处理
  - 同步等待：使用`future.wait()`确保子任务完成
- **深度控制**：限制递归深度≤10，避免创建过多线程
  - 线程创建和切换有开销
  - 过多线程导致竞争和上下文切换
- **实测效果**：在16核CPU上，加速比约1.54x，超越了std::sort()

---

## 三、算法核心代码及注解

### 3.1 三数取中法选择基准

```cpp
// 三数取中法选择枢轴
int medianOfThree(vector<int> &arr, int left, int right) {
  int mid = left + (right - left) / 2;  // 计算中间位置，避免溢出

  // 通过三次比较将arr[left], arr[mid], arr[right]排序
  // 排序后：arr[left] <= arr[mid] <= arr[right]
  if (arr[left] > arr[mid])
    swap(arr[left], arr[mid]);
  if (arr[left] > arr[right])
    swap(arr[left], arr[right]);
  if (arr[mid] > arr[right])
    swap(arr[mid], arr[right]);

  return mid;  // 返回中位数的索引
}
```

### 3.2 分区函数

```cpp
// 分区函数 - 将数组分为小于和大于基准的两部分
int partitionMedian(vector<int> &arr, int left, int right) {
  // 步骤1：选择基准并移到末尾
  int pivotIdx = medianOfThree(arr, left, right);  // 三数取中
  int pivot = arr[pivotIdx];                        // 保存基准值
  swap(arr[pivotIdx], arr[right]);                  // 移到最右端

  // 步骤2：分区操作（双指针法）
  int i = left - 1;  // i指针：维护小于等于pivot的区域边界
  
  for (int j = left; j < right; j++) {  // j指针：遍历数组
    if (arr[j] <= pivot) {
      i++;                      // 扩展左区域
      swap(arr[i], arr[j]);     // 将小元素交换到左区域
    }
  }
  
  // 步骤3：将基准放到正确位置（左右区域的分界点）
  swap(arr[i + 1], arr[right]);
  return i + 1;  // 返回基准的最终位置
}
```

### 3.3 混合优化快速排序

```cpp
void quicksortHybrid(vector<int> &arr, int left, int right, int k) {
  if (left < right) {
    // 优化1：小规模数组切换到插入排序
    if (right - left < k) {
      insertionSort(arr, left, right);
      return;  // 直接返回，不再递归
    }

    // 优化2：使用三数取中分区
    int pi = partitionMedian(arr, left, right);
    
    // 递归处理左右子数组
    quicksortHybrid(arr, left, pi - 1, k);   // 左子数组
    quicksortHybrid(arr, pi + 1, right, k);  // 右子数组
  }
}
```

### 3.4 并行快速排序

```cpp
void quicksortParallel(vector<int> &arr, int left, int right, int depth = 0) {
  // 终止条件1：数组为空或单元素
  if (left >= right)
    return;

  // 终止条件2：小数组或深度过深时使用单线程
  // THRESHOLD = 10000，深度限制 = 10
  if (right - left < THRESHOLD || depth > 10) {
    quicksortSingle(arr, left, right);  // 切换到单线程快排
    return;
  }

  // 分区操作
  int pi = partition(arr, left, right);

  // 并行优化：左子数组异步执行
  auto leftFuture = async(launch::async, [&]() {
    quicksortParallel(arr, left, pi - 1, depth + 1);
  });

  // 当前线程处理右子数组（避免线程闲置）
  quicksortParallel(arr, pi + 1, right, depth + 1);

  // 同步等待：确保左子数组排序完成
  leftFuture.wait();
}
```

### 3.5 插入排序（辅助算法）

```cpp
void insertionSort(vector<int> &arr, int left, int right) {
  // 从第二个元素开始，逐个插入到前面已排序的序列中
  for (int i = left + 1; i <= right; i++) {
    int key = arr[i];  // 保存待插入元素
    int j = i - 1;
    
    // 将大于key的元素后移，为key腾出插入位置
    while (j >= left && arr[j] > key) {
      arr[j + 1] = arr[j];  // 后移（而非交换，减少赋值）
      j--;
    }
    
    arr[j + 1] = key;  // 插入到正确位置
  }
}
```

---

## 四、实验结果分析

### 4.1 实验环境

- **操作系统**：Linux
- **编译器**：Clang (LLVM)
- **CPU核心数**：16核
- **数据规模**：100,000个随机整数

### 4.2 基准选择策略对比

**性能对比分析**：

| 策略         | 运行时间    | 相对性能         | 性能差异 |
| ------------ | ----------- | ---------------- | -------- |
| **固定基准** | **5.36 ms** | **100%（基准）** | -        |
| 随机基准     | 6.35 ms     | 84.4%            | 慢18.5%  |
| 三数取中     | 5.45 ms     | 98.3%            | 慢1.7%   |

**分析**：

1. **固定基准表现最佳（5.36ms）**：
   - 原因：测试数据为完全随机分布
   - 固定基准在随机数据上性能优秀
   - 无额外比较和随机数生成开销
   - **风险**：对于已排序或部分有序数据，性能会急剧下降

2. **随机基准表现最差（6.35ms，慢18.5%）**：
   - 随机数生成器（`mt19937`）开销较大
   - 每次分区都调用`uniform_int_distribution`
   - 虽然理论上避免最坏情况，但实际开销明显
   
3. **三数取中性能接近固定基准（5.45ms，仅慢1.7%）**：
   - 3次额外比较的开销极小（约0.09ms）
   - 在随机数据上性能与固定基准相当
   - 对有序数据的鲁棒性强
   

### 4.3 混合优化（K值影响分析）

**性能分析**：

| K值    | 运行时间    | 相对提升  | 与纯快排比较 | 分析            |
| ------ | ----------- | --------- | ------------ | --------------- |
| 5      | 5.12 ms     | -         | 6.05%        | K太小，频繁切换 |
| 10     | 4.89 ms     | 4.49%     | 10.28%       | 性能明显提升    |
| 15     | 4.83 ms     | 1.23%     | 11.38%       | 继续改善        |
| 20     | 4.74 ms     | 1.86%     | 13.03%       | 接近最优        |
| **30** | **4.69 ms** | **1.05%** | **13.94%**   | **最优值**      |

**分析**：

1. **持续改善趋势**：
   - K从5增加到30，性能持续提升
   - 说明在此数据规模下，K=30尚未达到插入排序的低效区间
   - 可能K=40或50会达到性能拐点

2. **边际收益递减**：
   - K: 5→10: 提升4.49%
   - K: 10→15: 提升1.23%
   - K: 20→30: 提升1.05%
   - 说明K=20-30是合理的工程权衡点

3. **性能提升显著**：
   - 最优混合策略比纯三数取中快排快13.94%
   - 从5.45ms降至4.69ms
   - 证明混合策略的有效性

### 4.4 并行化优化效果（16核CPU）

**并行性能深度分析**：

| 排序方法               | 运行时间    | 加速比    |
| ---------------------- | ----------- | --------- |
| 单线程快排（优化K=30） | ~4.69 ms    | 1.0x      |
| STL sort (单线程)      | 4.57 ms     | 1.03x     |
| **并行快排（16核）**   | **2.96 ms** | **1.58x** |

**结论**：

1. 主要瓶颈是内存带宽而非计算能力
2. 单线程STL sort性能非常好
3. 并行优势在大规模数据上更加明显
4. 并行化增加了代码复杂度，需要权衡

### 4.5 与其他排序算法对比

基于相同数据集（100,000个随机整数）的理论和实测对比：

| 排序算法           | 时间复杂度 | 空间复杂度 | 预估运行时间 | 相对性能   | 稳定性 |
| ------------------ | ---------- | ---------- | ------------ | ---------- | ------ |
| 冒泡排序           | O(n²)      | O(1)       | ~15,000 ms   | 1x         | 稳定   |
| 插入排序           | O(n²)      | O(1)       | ~6,000 ms    | 2.5x       | 稳定   |
| 快排(固定)         | O(n log n) | O(log n)   | 5.36 ms      | **2,800x** | 不稳定 |
| 快排(三数取中)     | O(n log n) | O(log n)   | 5.45 ms      | 2,752x     | 不稳定 |
| **快排(混合K=30)** | O(n log n) | O(log n)   | **4.69 ms**  | **3,199x** | 不稳定 |
| **STL sort**       | O(n log n) | O(log n)   | **4.57 ms**  | **3,283x** | 不稳定 |
| **快排(并行16核)** | O(n log n) | O(log n)   | **2.96 ms**  | **5,068x** | 不稳定 |

---

## 五、实验总结

### 5.1 主要收获

1. **算法优化的实践经验**：
   - 理论最优不等于实际最优（固定基准vs三数取中）
   - 小优化积累带来显著提升（14%性能提升）
   - 参数调优至关重要（K值从5到30的差异）

2. **性能分析的重要性**：
   - 随机基准的随机数开销被低估（18.5%性能损失）
   - 插入排序在K=30时仍优于递归快排
   - 并行化在10万元素规模下加速比有限（1.54x）

3. **分治策略的深入理解**：
   - 基准选择决定了"分"的质量
   - base case优化（插入排序）显著提升性能
   - 递归深度与栈空间的权衡

4. **并行编程的复杂性**：
   - 并行≠快速，需要权衡开销
   - 内存带宽是主要瓶颈（而非计算）
   - 16核仅获得1.54x加速比，效率9.6%
   - 深度和阈值控制是关键

5. **工程实践的思考**：
   - STL sort性能卓越（4.57ms），难以超越
   - 我们的混合优化（4.69ms）已经非常接近STL
   - 简单的优化（三数取中）效果显著且易实现

---

## 六、附录

### 6.1 完整实验环境

```
操作系统：  Linux
编译器：    Clang (LLVM)
C++标准：   C++11
CPU：       16核心处理器
数据集：    100,000个随机整数
```

### 6.2 编译与运行

**编译命令**：

```bash
# 编译优化版本（基准选择 + 混合优化）
clang++ -std=c++11 -O3 -march=native quicksort_optimization.cpp -o quicksort_optimization

# 编译并行版本（需要链接pthread）
clang++ -std=c++11 -O3 -march=native -pthread parallel_quicksort.cpp -o parallel_quicksort
```

**运行命令**：

```bash
# 进入工作目录
cd ~/workspace/AlgorithmLab/QuickSort

# 运行优化版本
./quicksort_optimization

# 运行并行版本
./parallel_quicksort
```

### 6.3 实际运行输出

**优化版本输出**：

```
ethangao@EthanGao:~/workspace/AlgorithmLab/QuickSort$ ./quicksort_optimization
【第一部分：基准选择策略】
1) 固定基准: 5.36 毫秒
2) 随机基准: 6.35 毫秒
3) 三数取中: 5.45 毫秒

【第二部分：三数取中 + 插入排序混合优化】
K =  5: 5.12 毫秒
K = 10: 4.89 毫秒
K = 15: 4.83 毫秒
K = 20: 4.74 毫秒
K = 30: 4.69 毫秒

========== 性能对比 ==========
基准选择最优: 三数取中 (5.45 毫秒)
混合优化最优: K = 30 (4.69 毫秒)
优化提升: 13.99%
```

**并行版本输出**：

```
ethangao@EthanGao:~/workspace/AlgorithmLab/QuickSort$ ./parallel_quicksort
========== 性能对比 ==========
STL sort 运行时间: 4.57 毫秒
多线程快速排序运行时间: 2.96 毫秒
加速比: 1.54x (快 54.39%)
```

### 6.4 文件格式说明

**输入文件（data.txt）**：
```
100000
42705 54648 73121 30162 20466 91547 78844 74008 50026 87262 ...
```
- 第一行：数组长度n
- 第二行：n个整数，空格分隔

**输出文件（sorted.txt）**：
```
1 1 2 2 3 4 4 6 7 8 12 13 15 16 16 17 17 18 18 18 19 19 19 21 ...
```
- 单行：排序后的数组，空格分隔

### 6.5 代码仓库

完整代码已提交到GitHub：
- **仓库**：`github.com/91gaozhidao/AlgorithmLab`
- **目录**：`QuickSort/`
- **提交ID**：`0d96113519c5cdd2ebeb3666be77d18204e19aec`

**文件列表**：
```
QuickSort/
├── Lab1.md                      # 实验要求
├── data.txt                     # 测试数据（100,000个整数）
├── quicksort_optimization.cpp   # 优化版本源码
├── quicksort_optimization       # 优化版本可执行文件
├── parallel_quicksort.cpp       # 并行版本源码
├── parallel_quicksort           # 并行版本可执行文件
└── sorted.txt                   # 排序结果输出
```
